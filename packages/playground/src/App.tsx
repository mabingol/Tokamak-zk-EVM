import React, { useState, useEffect } from 'react';
import { fetchTransactionBytecode } from '../utils/etherscanApi';
import { Buffer } from 'buffer';
import { createEVM } from '../../frontend/synthesizer/src/constructors';
import { hexToBytes, Address } from '../../frontend/synthesizer/libs/util/dist/esm/index.js';
import { TON_CONTRACT_CODE } from './constant/evm.js';
import { setupEVM } from '../utils/setupEVM';
import logo from '/logo.png';
import downloadIcon from '/download.svg';
import { getValueDecimal, summarizeHex, serializePlacements } from '../helpers/helpers';
import './App.css';

window.Buffer = window.Buffer || Buffer;

type LogCardProps = {
  contractAddress: string;
  keyValue: string;
  valueDecimal: string;
  valueHex: string;
  summarizeAddress?: boolean;
};

const LogCard: React.FC<LogCardProps> = ({
  contractAddress,
  keyValue,
  valueDecimal,
  valueHex,
  summarizeAddress = false,
}) => (
  <div className="log-card">
    <div>
      <strong>Contract Address:</strong>{' '}
      <span title={contractAddress}>
        {summarizeAddress ? summarizeHex(contractAddress) : contractAddress}
      </span>
    </div>
    <div>
      <strong>Key:</strong>{' '}
      <span title={keyValue}>{summarizeHex(keyValue)}</span>
    </div>
    <div>
      <strong>Value (Decimal):</strong>{' '}
      <span>{valueDecimal || getValueDecimal(valueHex)}</span>
    </div>
    <div>
      <strong>Value (Hex):</strong>{' '}
      <span title={valueHex}>{valueHex}</span>
    </div>
  </div>
);

export interface FormattedLog {
  address: string;
  topics: {
      signature: string;
      from: string;
      to: string;
  };
  data: {
      hex: string;
      value: string;
  };
}

export function formatLogsStructured(logs: any[]): FormattedLog[] {
  return logs.map((log: any) => {
      const topics = log[1].map((topic: any) => `0x${Buffer.from(topic).toString('hex')}`);
      const dataHex = `0x${Buffer.from(log[2]).toString('hex')}`;
      
      return {
          address: `0x${Buffer.from(log[0]).toString('hex')}`,
          topics: {
              signature: topics[0],
              from: `0x${topics[1].slice(-40)}`,
              to: `0x${topics[2].slice(-40)}`
          },
          data: {
              hex: dataHex,
              value: parseInt(dataHex, 16).toString()
          }
      };
  });
}


const App: React.FC = () => {
  const [transactionId, setTransactionId] = useState('');
  const [status, setStatus] = useState<string | null>(null);
  const [serverData, setServerData] = useState<{
    permutation: string | null;
    placementInstance: string | null;
  } | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const [storageLoad, setStorageLoad] = useState<any[]>([]);
  const [placementLogs, setPlacementLogs] = useState<any[]>([]);
  const [storageStore, setStorageStore] = useState<any[]>([]);
  const [evmContractAddress, setEvmContractAddress] = useState<string>('');
  const [activeTab, setActiveTab] = useState('storageLoad');

  const processTransaction = async (txId: string) => {
    try {
      setIsProcessing(true);
      setStatus('Fetching bytecode from Etherscan...');
      setStorageLoad([]);
      setPlacementLogs([]);
      setStorageStore([]);
      setServerData(null);

      const { bytecode, from, to } = await fetchTransactionBytecode(txId);
      if (!bytecode || bytecode.length < 2) {
        throw new Error('Invalid bytecode received. Check your transaction ID.');
      }

      const contractCode = TON_CONTRACT_CODE;
      setStatus('Creating and running the EVM...');
      const evm = await createEVM();
      const contractAddr = new Address(hexToBytes(to));
      setEvmContractAddress(contractAddr.toString());
      const sender = new Address(hexToBytes(from));
      await setupEVM(evm, from, contractCode, contractAddr, sender);

      const res = await evm.runCode({
        caller: sender,
        to: contractAddr,
        code: contractCode,
        data: hexToBytes(bytecode),
      });

      if (!res.runState?.synthesizer?.placements) {
        throw new Error('No placements generated by the synthesizer.');
      }

      const placementsMap = res.runState.synthesizer.placements;
      const STORAGE_IN_PLACEMENT_INDEX = 0;
      const STORAGE_OUT_PLACEMENT_INDEX = 1;
      const RETURN_PLACEMENT_INDEX = 2;

      const storageLoadPlacement = placementsMap.get(STORAGE_IN_PLACEMENT_INDEX);
      const logsPlacement = placementsMap.get(STORAGE_OUT_PLACEMENT_INDEX);
      const storageStorePlacement = placementsMap.get(RETURN_PLACEMENT_INDEX);

      const storageLoadData = storageLoadPlacement?.inPts || [];
      //const logsData = logsPlacement?.outPts || [];
      const storageStoreData = storageStorePlacement?.outPts || [];

      if (res.logs) {
          const formattedLogs = formatLogsStructured(res.logs);
          setPlacementLogs(formattedLogs);
      } else {
          setPlacementLogs([]);
      }

      setStorageLoad(storageLoadData);
      //setPlacementLogs(logsData);
      setStorageStore(storageStoreData);

      const placementsObj = Object.fromEntries(placementsMap.entries());

      setStatus('Finalizing placements on the server...');
      const response = await fetch('api/finalize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: serializePlacements(placementsObj),
      });
      if (!response.ok) {
        throw new Error(`Server returned status ${response.status}`);
      }
      const json = await response.json();

      if (!json.ok) {
        throw new Error(json.error || 'Unknown server error.');
      }

      const { permutation, placementInstance } = json.data || {};
      setServerData({ permutation, placementInstance });
      setStatus(null);
      sessionStorage.removeItem('pendingTransactionId');
    } catch (error) {
      console.error('Error:', error);
      setStatus(`Error: ${error instanceof Error ? error.message : String(error)}`);
      sessionStorage.removeItem('pendingTransactionId');
    } finally {
      setIsProcessing(false);
    }
  };

  const handleSubmit = () => {
    if (isProcessing) return;
    sessionStorage.setItem('pendingTransactionId', transactionId);
    window.location.reload();
  };

  useEffect(() => {
    const pendingTxId = sessionStorage.getItem('pendingTransactionId');
    if (pendingTxId) {
      setTransactionId(pendingTxId);
      processTransaction(pendingTxId);
    }
  }, []);

  const handleDownload = (fileContent: string | null, fileName: string) => {
    if (!fileContent) return;
    const blob = new Blob([fileContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    link.click();
    URL.revokeObjectURL(url);
  };

  const renderActiveTab = () => {
    if (activeTab === 'storageLoad') {
      return storageLoad.length ? (
        storageLoad.map((item, index) => (
          <LogCard
            key={index}
            contractAddress={item.contractAddress || evmContractAddress}
            keyValue={item.key}
            valueDecimal={item.valueDecimal}
            valueHex={item.valueHex}
          />
        ))
      ) : (
        <p>No storage load data.</p>
      );
    } else if (activeTab === 'logs') {
      return placementLogs.length ? (
        placementLogs.map((log, index) => (
          <div key={index} className="log-card">
            <div>
              {/*<strong>Token Address:</strong> {log.address}*/}
            </div>
            <div>
              <strong>Topics:</strong>
              <div className="log-topics">
                <div><strong>Signature:</strong> {log.topics.signature}</div>
                <div><strong>From:</strong> {log.topics.from}</div>
                <div><strong>To:</strong> {log.topics.to}</div>
              </div>
            </div>
            <div>
              <strong>Data:</strong>
              <div className="log-data" title={`Hex: ${log.data.hex}\nValue: ${log.data.value}`}>
                <div><strong>Hex:</strong> {log.data.hex}</div>
                <div><strong>Value (Decimal):</strong> {log.data.value}</div>
              </div>
            </div>
          </div>
        ))
      ) : (
        <p>No logs data.</p>
      );
    }
     else if (activeTab === 'storageStore') {
      return storageStore.length ? (
        storageStore.map((item, index) => {
          const contractAddress = Array.isArray(item) ? item[0] : item.contractAddress;
          const key = Array.isArray(item) ? item[1] : item.key;
          const valueDecimal = Array.isArray(item) ? item[2] : item.valueDecimal;
          const valueHex = Array.isArray(item) ? item[3] : item.valueHex;
          return (
            <LogCard
              key={index}
              contractAddress={contractAddress}
              keyValue={key}
              valueDecimal={valueDecimal}
              valueHex={valueHex}
              summarizeAddress={true}
            />
          );
        })
      ) : (
        <p>No storage store data.</p>
      );
    }
    return null;
  };

  return (
    <div className="container">
      <div className="logo-container">
        <img src={logo} alt="Synthesizer Logo" className="logo-image" />
      </div>
      <div className="title-container">
        <h1 className="main-title">Synthesizer</h1>
        <h2 className="subtitle">Developer Playground</h2>
      </div>
      <div className="input-button-container">
        <input
          type="text"
          value={transactionId}
          onChange={(e) => setTransactionId(e.target.value)}
          placeholder="Enter Transaction ID"
          className="transaction-input"
          disabled={isProcessing}
        />
        <button
          onClick={handleSubmit}
          className={`btn-process ${isProcessing ? 'disabled' : ''}`}
          disabled={isProcessing}
        >
          {isProcessing ? 'Processing...' : ''}
        </button>
      </div>

      {status && (
        <div className={status.startsWith('Error') ? 'error-box' : 'status-download-container'}>
          <div className="error-content">{status.replace('Error: ', '')}</div>
        </div>
      )}

      {(storageLoad.length > 0 || placementLogs.length > 0 || storageStore.length > 0) && (
        <div className="big-box">
          <div className="tab-switcher">
            <button
              className={activeTab === 'storageLoad' ? 'active' : ''}
              onClick={() => setActiveTab('storageLoad')}
            >
              Storage Load
            </button>
            <button
              className={activeTab === 'logs' ? 'active' : ''}
              onClick={() => setActiveTab('logs')}
            >
              Logs
            </button>
            <button
              className={activeTab === 'storageStore' ? 'active' : ''}
              onClick={() => setActiveTab('storageStore')}
            >
              Storage Store
            </button>
          </div>
          <div className="fixed-box">{renderActiveTab()}</div>
          {serverData && (
            <div className="download-buttons-container">
              {serverData.permutation && (
                <button
                  onClick={() => handleDownload(serverData.permutation, 'permutation.json')}
                  className="btn-download btn-permutation"
                  disabled={isProcessing}
                >
                  <img src={downloadIcon} alt="download" className="download-icon" />
                  Permutation
                </button>
              )}
              {serverData.placementInstance && (
                <button
                  onClick={() =>
                    handleDownload(serverData.placementInstance, 'placementInstance.json')
                  }
                  className="btn-download btn-placement"
                  disabled={isProcessing}
                >
                  <img src={downloadIcon} alt="download" className="download-icon" />
                  Placement Instance
                </button>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default App;
